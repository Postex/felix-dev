/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.felix.ipojo.manipulation;

import org.objectweb.asm.Type;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

import static org.objectweb.asm.Opcodes.*;

/**
 * This class contains a register of all fields which has to / should be manipulated.
 * <br>
 * This is introduced to fix an issue when an outer class refers to an inner static class which is pojoized. See PTX-9243.
 *     // store all fields which will be manipulated as we have to intercept direct field access also
 *     // In pre JDK 11, a field access is compiled with a bridge method, that bridge method is injected in the
 *     // target class. That method is manipulated automatically by the manipulator.
 *     // But from JDK 11 and higher, there is no bridge method, only the direct field access. On the caller side
 *     // we don't know whether the field is manipulated or not. So we have to create a register of manipulated fields.
 *     // See PTX-9243
 */
public class GlobalManipulationFieldsRegistry {
    private Map<String, Map<String, Field>> m_fieldsRegistry = new HashMap<>();

    public boolean isFieldInManipulationScope(String className, String fieldName) {
        Map<String, Field> fields = m_fieldsRegistry.get(className);
        if (fields == null) {
            return false;
        }
        return fields.containsKey(fieldName);
    }

    private boolean isManipulatedField(String name) {
        return ((ClassManipulator.IM_FIELD.equals(name))
                || (name.startsWith(ClassManipulator.FIELD_FLAG_PREFIX))
                || (name.startsWith(ClassManipulator.METHOD_FLAG_PREFIX)));
    }

    public boolean registerField(String className, String fieldName, Type type, int access) {
        if (fieldName.startsWith("class$")) { // Does not add class$* field generated by 'x.class'
            return false;
        } else if ((access & ACC_STATIC) == ACC_STATIC) {
            return false;
        } else if ((access & ACC_SYNTHETIC) == ACC_SYNTHETIC) {
            return false;
        } else if (isManipulatedField(fieldName)) {
            return false;
        }

        String plainType;
        if (type.getSort() == Type.ARRAY) {
            if (type.getInternalName().startsWith("L")) {
                String internalType = type.getInternalName().substring(1);
                String nameType = internalType.replace('/', '.');
                plainType = nameType + "[]";
            } else {
                String nameType = type.getClassName().substring(0,
                        type.getClassName().length() - 2);
                plainType = nameType + "[]";
            }
        } else {
            plainType = type.getClassName();
        }
        Map<String, Field> fields = m_fieldsRegistry.get(className);
        if (fields == null) {
            fields = new HashMap<>();
            m_fieldsRegistry.put(className, fields);
        }
        fields.put(fieldName, new Field(access, plainType));

        return true;
    }

    public boolean isFieldFinal(String className, String fieldName) {
        Map<String, Field> fields = m_fieldsRegistry.get(className);
        if (fields == null) {
            throw new IllegalArgumentException("No fields registered for class " + className);
        }
        Field field = fields.get(fieldName);
        if (field == null) {
            throw new IllegalArgumentException("Field " + fieldName + " is not registered for class " + className);
        }
        return field.isFinal();
    }

    public Map<String, String> getFieldsForClass(String className) {
        Map<String, Field> fields = m_fieldsRegistry.get(className);
        if (fields == null) {
            return Collections.emptyMap();
        }
        return fields.entrySet().stream().collect(Collectors.toMap(
                Map.Entry::getKey,
                e -> e.getValue().getPlainType())
        );

    }

    private class Field {
        private int access;
        private String plainType;

        private Field(int access, String plainType) {
            this.access = access;
            this.plainType = plainType;
        }

        public int getAccess() {
            return access;
        }

        public String getPlainType() {
            return plainType;
        }

        public boolean isFinal() {
            return (access & ACC_FINAL) == ACC_FINAL;
        }
    }
}